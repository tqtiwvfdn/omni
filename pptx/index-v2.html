<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTMLå¸ƒå±€è¿˜åŸ to PPTX è½¬æ¢å™¨</title>
    <script src="/console/style/tailwindcss.3.0.23.js"></script>
    <script src="/scripts/pptxgen.bundle.js"></script>
    <style>
        .loading-spinner {
            border: 3px solid #f3f4f6;
            border-top: 3px solid #3b82f6;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .render-iframe {
            width: 100%;
            height: 100%;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            background: white;
        }

        .element-box {
            position: absolute;
            border: 1px dashed #3b82f6;
            background: rgba(59, 130, 246, 0.1);
            pointer-events: none;
            font-size: 10px;
            color: #1e40af;
            z-index: 1000;
        }

        .debug-info {
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            max-width: 200px;
            word-wrap: break-word;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-blue-50 to-indigo-100 min-h-screen">
    <div class="container mx-auto px-4 py-6">
        <!-- å¤´éƒ¨ -->
        <div class="text-center mb-6">
            <h1 class="text-3xl font-bold text-gray-800 mb-2">HTMLå¸ƒå±€è¿˜åŸ to PPTX</h1>
            <p class="text-gray-600">ç²¾ç¡®è¿˜åŸç½‘é¡µå¸ƒå±€ä¸ºå¯ç¼–è¾‘çš„PowerPointå…ƒç´ </p>
        </div>

        <!-- ä¸»è¦å†…å®¹åŒºåŸŸ -->
        <div class="grid grid-cols-12 gap-6">
            <!-- å·¦ä¾§ï¼šæ“ä½œé¢æ¿ -->
            <div class="col-span-4">
                <!-- URLç®¡ç† -->
                <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
                    <h2 class="text-lg font-semibold text-gray-800 mb-4">ğŸ“„ URLç®¡ç†</h2>
                    
                    <div class="space-y-4">
                        <!-- URL è¾“å…¥ -->
                        <div>
                            <div class="flex gap-2">
                                <input 
                                    type="url" 
                                    id="urlInput" 
                                    placeholder="è¾“å…¥ç½‘é¡µURL"
                                    class="flex-1 px-3 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 text-sm"
                                >
                                <button 
                                    onclick="addUrl()" 
                                    class="px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 transition-colors text-sm"
                                >
                                    æ·»åŠ 
                                </button>
                            </div>
                        </div>

                        <!-- URL åˆ—è¡¨ -->
                        <div class="space-y-2 max-h-40 overflow-y-auto" id="urlList">
                            <!-- URL items will be added here -->
                        </div>

                        <div class="flex gap-2">
                            <button 
                                onclick="loadSelectedUrl()" 
                                class="flex-1 px-3 py-2 bg-green-500 text-white rounded-md hover:bg-green-600 transition-colors text-sm"
                            >
                                åŠ è½½é¢„è§ˆ
                            </button>
                            <button 
                                onclick="clearUrls()" 
                                class="px-3 py-2 bg-red-500 text-white rounded-md hover:bg-red-600 transition-colors text-sm"
                            >
                                æ¸…ç©º
                            </button>
                        </div>
                    </div>
                </div>

                <!-- åˆ†ææ§åˆ¶ -->
                <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
                    <h2 class="text-lg font-semibold text-gray-800 mb-4">ğŸ” é¡µé¢åˆ†æ</h2>
                    
                    <div class="space-y-4">
                        <button 
                            onclick="analyzeCurrentPage()" 
                            id="analyzeBtn"
                            class="w-full px-4 py-2 bg-purple-500 text-white rounded-md hover:bg-purple-600 transition-colors text-sm"
                        >
                            åˆ†æé¡µé¢ç»“æ„
                        </button>

                        <div class="flex items-center space-x-2">
                            <input type="checkbox" id="showElementBounds" onchange="toggleElementBounds()">
                            <label for="showElementBounds" class="text-sm text-gray-700">æ˜¾ç¤ºå…ƒç´ è¾¹ç•Œ</label>
                        </div>

                        <!-- åˆ†æç»“æœ -->
                        <div id="analysisResult" class="text-sm text-gray-600">
                            <div class="text-center text-gray-400 py-4">ç­‰å¾…åˆ†æ...</div>
                        </div>
                    </div>
                </div>

                <!-- è½¬æ¢è®¾ç½® -->
                <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
                    <h2 class="text-lg font-semibold text-gray-800 mb-4">âš™ï¸ è½¬æ¢è®¾ç½®</h2>
                    
                    <div class="space-y-4">
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">PPTæ ‡é¢˜</label>
                            <input 
                                type="text" 
                                id="pptTitle" 
                                value="ç½‘é¡µå¸ƒå±€è¿˜åŸ"
                                class="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 text-sm"
                            >
                        </div>
                        
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">å¹»ç¯ç‰‡å°ºå¯¸</label>
                            <select id="slideSize" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 text-sm">
                                <option value="16:9">16:9 å®½å±</option>
                                <option value="4:3">4:3 æ ‡å‡†</option>
                            </select>
                        </div>

                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">æœ€å°å…ƒç´ å°ºå¯¸(px)</label>
                            <input 
                                type="number" 
                                id="minElementSize" 
                                value="20"
                                min="5"
                                max="100"
                                class="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 text-sm"
                            >
                        </div>

                        <div class="space-y-2">
                            <div class="flex items-center">
                                <input type="checkbox" id="includeBackground" checked class="mr-2">
                                <label for="includeBackground" class="text-sm text-gray-700">åŒ…å«èƒŒæ™¯è‰²</label>
                            </div>
                            <div class="flex items-center">
                                <input type="checkbox" id="includeImages" checked class="mr-2">
                                <label for="includeImages" class="text-sm text-gray-700">è½¬æ¢å›¾ç‰‡ä¸ºå½¢çŠ¶</label>
                            </div>
                            <div class="flex items-center">
                                <input type="checkbox" id="mergeSimilar" class="mr-2">
                                <label for="mergeSimilar" class="text-sm text-gray-700">åˆå¹¶ç›¸ä¼¼å…ƒç´ </label>
                            </div>
                        </div>

                        <button 
                            onclick="generatePPTX()" 
                            id="generateBtn"
                            class="w-full px-4 py-3 bg-gradient-to-r from-blue-500 to-purple-600 text-white rounded-md hover:from-blue-600 hover:to-purple-700 transition-all text-sm font-medium"
                        >
                            ğŸš€ ç”Ÿæˆå¯ç¼–è¾‘PPTX
                        </button>

                        <!-- è¿›åº¦æ˜¾ç¤º -->
                        <div id="progressInfo" class="hidden">
                            <div class="flex items-center justify-center space-x-2 py-2">
                                <div class="loading-spinner"></div>
                                <span class="text-sm text-gray-600" id="progressText">å¤„ç†ä¸­...</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- çŠ¶æ€æ˜¾ç¤º -->
                <div id="statusContainer" class="hidden">
                    <div class="bg-white rounded-lg shadow-lg p-4">
                        <div class="text-sm" id="statusMessage"></div>
                    </div>
                </div>
            </div>

            <!-- å³ä¾§ï¼šé¢„è§ˆçª—å£ -->
            <div class="col-span-8">
                <div class="bg-white rounded-lg shadow-lg p-6">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-lg font-semibold text-gray-800">ğŸ–¥ï¸ é¡µé¢é¢„è§ˆ</h2>
                        <div class="flex gap-2">
                            <button onclick="refreshPreview()" class="px-3 py-1 bg-gray-500 text-white rounded text-sm hover:bg-gray-600">
                                åˆ·æ–°
                            </button>
                            <span class="text-sm text-gray-600" id="currentUrl">æœªåŠ è½½é¡µé¢</span>
                        </div>
                    </div>
                    
                    <!-- iframeé¢„è§ˆ -->
                    <div class="relative">
                        <iframe id="previewFrame" class="render-iframe" src="about:blank"></iframe>
                        <div id="elementOverlay" class="absolute top-0 left-0 w-full h-full pointer-events-none"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let urls = [];
        let currentPageUrl = '';
        let analyzedElements = [];
        let selectedUrlIndex = 0;

        // æ ·å¼è½¬æ¢å·¥å…·
        const StyleConverter = {
            // RGB/RGBA è½¬åå…­è¿›åˆ¶
            rgbToHex(rgb) {
                if (!rgb || rgb === 'transparent' || rgb === 'rgba(0, 0, 0, 0)') return null;
                
                const rgbMatch = rgb.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
                if (rgbMatch) {
                    const r = parseInt(rgbMatch[1]).toString(16).padStart(2, '0');
                    const g = parseInt(rgbMatch[2]).toString(16).padStart(2, '0');
                    const b = parseInt(rgbMatch[3]).toString(16).padStart(2, '0');
                    return r + g + b;
                }
                
                if (rgb.startsWith('#')) {
                    return rgb.substring(1);
                }
                
                // å¸¸è§é¢œè‰²åç§°
                const colorMap = {
                    'black': '000000', 'white': 'FFFFFF', 'red': 'FF0000',
                    'green': '008000', 'blue': '0000FF', 'yellow': 'FFFF00',
                    'gray': '808080', 'grey': '808080', 'transparent': null
                };
                
                return colorMap[rgb.toLowerCase()] || '000000';
            },

            // åƒç´ è½¬è‹±å¯¸ (PPTä½¿ç”¨è‹±å¯¸)
            pxToInch(px) {
                return parseFloat(px) / 96; // 96 DPI
            },

            // åƒç´ è½¬ç‚¹ (å­—ä½“å¤§å°)
            pxToPt(px) {
                return Math.max(8, Math.round(parseFloat(px) * 0.75));
            },

            // è·å–å­—ä½“ç²—ç»†
            getFontWeight(weight) {
                const w = parseInt(weight) || 400;
                return w >= 600;
            },

            // æ–‡æœ¬å¯¹é½è½¬æ¢
            getTextAlign(align) {
                const alignMap = {
                    'left': 'left',
                    'center': 'center',
                    'right': 'right',
                    'justify': 'justify'
                };
                return alignMap[align] || 'left';
            }
        };

        // é¡µé¢åˆ†æå™¨
        const PageAnalyzer = {
            analyzeElements(doc) {
                const elements = [];
                const minSize = parseInt(document.getElementById('minElementSize').value) || 20;
                
                // éå†æ‰€æœ‰å¯è§å…ƒç´ 
                const walker = doc.createTreeWalker(
                    doc.body,
                    NodeFilter.SHOW_ELEMENT,
                    {
                        acceptNode: (node) => {
                            // è¿‡æ»¤è„šæœ¬ã€æ ·å¼ç­‰æ— ç”¨å…ƒç´ 
                            if (['SCRIPT', 'STYLE', 'META', 'LINK'].includes(node.tagName)) {
                                return NodeFilter.FILTER_REJECT;
                            }
                            
                            const style = doc.defaultView.getComputedStyle(node);
                            
                            // è¿‡æ»¤ä¸å¯è§å…ƒç´ 
                            if (style.display === 'none' || 
                                style.visibility === 'hidden' ||
                                parseFloat(style.opacity) < 0.1) {
                                return NodeFilter.FILTER_REJECT;
                            }
                            
                            return NodeFilter.FILTER_ACCEPT;
                        }
                    }
                );

                let node;
                while (node = walker.nextNode()) {
                    const rect = node.getBoundingClientRect();
                    const style = doc.defaultView.getComputedStyle(node);
                    
                    // åªå¤„ç†æœ‰è¶³å¤Ÿå¤§å°çš„å…ƒç´ 
                    if (rect.width >= minSize && rect.height >= minSize) {
                        const elementData = this.extractElementData(node, rect, style, doc);
                        if (elementData) {
                            elements.push(elementData);
                        }
                    }
                }

                // æŒ‰ä½ç½®æ’åº (ä»ä¸Šåˆ°ä¸‹ï¼Œä»å·¦åˆ°å³)
                elements.sort((a, b) => {
                    const yDiff = a.position.y - b.position.y;
                    return yDiff !== 0 ? yDiff : a.position.x - b.position.x;
                });

                return elements;
            },

            extractElementData(element, rect, style, doc) {
                // è·å–æ–‡æœ¬å†…å®¹
                const text = this.getElementText(element);
                
                // è·å–èƒŒæ™¯è‰²
                const bgColor = StyleConverter.rgbToHex(style.backgroundColor);
                const textColor = StyleConverter.rgbToHex(style.color);
                
                // æ„å»ºå…ƒç´ æ•°æ®
                const elementData = {
                    type: this.getElementType(element),
                    tagName: element.tagName,
                    text: text,
                    position: {
                        x: rect.left,
                        y: rect.top,
                        width: rect.width,
                        height: rect.height
                    },
                    style: {
                        fontSize: StyleConverter.pxToPt(style.fontSize),
                        fontFamily: style.fontFamily.split(',')[0].replace(/['"]/g, '').trim(),
                        fontWeight: StyleConverter.getFontWeight(style.fontWeight),
                        color: textColor,
                        backgroundColor: bgColor,
                        textAlign: StyleConverter.getTextAlign(style.textAlign),
                        lineHeight: parseFloat(style.lineHeight) || 1.2
                    },
                    attributes: {
                        href: element.href || null,
                        src: element.src || null,
                        alt: element.alt || null
                    }
                };

                return elementData;
            },

            getElementText(element) {
                // è·å–ç›´æ¥æ–‡æœ¬å†…å®¹ï¼Œé¿å…é‡å¤å­å…ƒç´ æ–‡æœ¬
                let text = '';
                
                for (let child of element.childNodes) {
                    if (child.nodeType === Node.TEXT_NODE) {
                        const textContent = child.textContent.trim();
                        if (textContent) {
                            text += textContent + ' ';
                        }
                    }
                }
                
                // å¦‚æœæ²¡æœ‰ç›´æ¥æ–‡æœ¬ï¼Œè·å–ç¬¬ä¸€å±‚å­å…ƒç´ çš„æ–‡æœ¬
                if (!text.trim() && element.children.length === 1) {
                    const child = element.children[0];
                    if (['SPAN', 'A', 'STRONG', 'EM', 'B', 'I'].includes(child.tagName)) {
                        text = child.textContent.trim();
                    }
                }
                
                return text.trim().substring(0, 500); // é™åˆ¶é•¿åº¦
            },

            getElementType(element) {
                const tag = element.tagName.toLowerCase();
                
                if (['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tag)) return 'heading';
                if (['p', 'div', 'span'].includes(tag)) return 'text';
                if (tag === 'img') return 'image';
                if (tag === 'a') return 'link';
                if (['ul', 'ol', 'li'].includes(tag)) return 'list';
                if (['button', 'input'].includes(tag)) return 'control';
                
                return 'container';
            }
        };

        // PPTX ç”Ÿæˆå™¨
        const PPTXGenerator = {
            async generate(elements, options = {}) {
                const pptx = new PptxGenJS();
                
                // è®¾ç½®å¹»ç¯ç‰‡å°ºå¯¸
                const slideSize = options.slideSize || '16:9';
                let slideWidth = 10, slideHeight = 5.625;
                
                if (slideSize === '4:3') {
                    slideHeight = 7.5;
                }
                
                pptx.defineLayout({ name: 'Custom', width: slideWidth, height: slideHeight });
                pptx.layout = 'Custom';
                
                // è®¾ç½®æ¼”ç¤ºæ–‡ç¨¿å±æ€§
                pptx.title = options.title || 'ç½‘é¡µå¸ƒå±€è¿˜åŸ';
                pptx.subject = 'HTML to PPTX è½¬æ¢';
                pptx.author = 'HTML Layout Converter';

                // åˆ›å»ºå¹»ç¯ç‰‡
                const slide = pptx.addSlide();

                // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹
                const iframe = document.getElementById('previewFrame');
                const iframeRect = iframe.getBoundingClientRect();
                const scaleX = slideWidth / iframeRect.width;
                const scaleY = slideHeight / iframeRect.height;
                const scale = Math.min(scaleX, scaleY) * 0.9; // ç•™ç‚¹è¾¹è·

                console.log('å…ƒç´ æ€»æ•°:', elements.length);
                console.log('ç¼©æ”¾æ¯”ä¾‹:', scale);

                // æ·»åŠ æ‰€æœ‰å…ƒç´ åˆ°å¹»ç¯ç‰‡
                let addedCount = 0;
                for (const element of elements) {
                    try {
                        const added = await this.addElementToSlide(slide, element, scale, slideWidth, slideHeight);
                        if (added) addedCount++;
                    } catch (error) {
                        console.warn('æ·»åŠ å…ƒç´ å¤±è´¥:', error, element);
                    }
                }

                console.log('æˆåŠŸæ·»åŠ å…ƒç´ æ•°é‡:', addedCount);

                // æ·»åŠ é¡µé¢ä¿¡æ¯
                slide.addText(`æ¥æº: ${currentPageUrl}`, {
                    x: 0.1, y: slideHeight - 0.4, w: slideWidth - 0.2, h: 0.3,
                    fontSize: 8,
                    color: '666666',
                    hyperlink: currentPageUrl ? { url: currentPageUrl } : undefined
                });

                return pptx;
            },

            async addElementToSlide(slide, element, scale, slideWidth, slideHeight) {
                // è®¡ç®—ä½ç½®å’Œå°ºå¯¸
                const x = StyleConverter.pxToInch(element.position.x * scale);
                const y = StyleConverter.pxToInch(element.position.y * scale);
                const w = StyleConverter.pxToInch(element.position.width * scale);
                const h = StyleConverter.pxToInch(element.position.height * scale);

                // æ£€æŸ¥æ˜¯å¦åœ¨å¹»ç¯ç‰‡èŒƒå›´å†…
                if (x >= slideWidth || y >= slideHeight || w < 0.1 || h < 0.1) {
                    return false;
                }

                // æ„å»ºåŸºæœ¬é€‰é¡¹
                const baseOptions = {
                    x: Math.max(0, x),
                    y: Math.max(0, y),
                    w: Math.min(w, slideWidth - x),
                    h: Math.min(h, slideHeight - y)
                };

                // æ ¹æ®å…ƒç´ ç±»å‹å¤„ç†
                if (element.type === 'image' && element.attributes.src) {
                    // å›¾ç‰‡å…ƒç´ è½¬ä¸ºå½¢çŠ¶
                    slide.addShape(pptx.shapes.RECTANGLE, {
                        ...baseOptions,
                        fill: { color: 'E0E0E0' },
                        line: { color: 'CCCCCC', width: 1 }
                    });
                    
                    // æ·»åŠ å›¾ç‰‡æ ‡è¯†æ–‡æœ¬
                    slide.addText(`[å›¾ç‰‡: ${element.attributes.alt || 'å›¾åƒ'}]`, {
                        ...baseOptions,
                        fontSize: Math.max(8, element.style.fontSize),
                        color: '666666',
                        align: 'center',
                        valign: 'middle'
                    });
                } else if (element.text && element.text.trim()) {
                    // æ–‡æœ¬å…ƒç´ 
                    const textOptions = {
                        ...baseOptions,
                        fontSize: Math.max(8, element.style.fontSize),
                        color: element.style.color || '000000',
                        bold: element.style.fontWeight,
                        align: element.style.textAlign,
                        valign: 'top',
                        wrap: true,
                        autoFit: true
                    };

                    // æ·»åŠ èƒŒæ™¯è‰²
                    if (element.style.backgroundColor && document.getElementById('includeBackground').checked) {
                        textOptions.fill = { color: element.style.backgroundColor };
                    }

                    // é“¾æ¥å¤„ç†
                    if (element.attributes.href) {
                        textOptions.hyperlink = { url: element.attributes.href };
                    }

                    slide.addText(element.text, textOptions);
                } else {
                    // å®¹å™¨å…ƒç´ è½¬ä¸ºå½¢çŠ¶
                    if (element.style.backgroundColor && document.getElementById('includeBackground').checked) {
                        slide.addShape(pptx.shapes.RECTANGLE, {
                            ...baseOptions,
                            fill: { color: element.style.backgroundColor },
                            line: { color: element.style.backgroundColor, width: 0 }
                        });
                    }
                }

                return true;
            }
        };

        // UI æ§åˆ¶å‡½æ•°
        function addUrl() {
            const urlInput = document.getElementById('urlInput');
            const url = urlInput.value.trim();
            
            if (url && isValidUrl(url)) {
                if (!urls.includes(url)) {
                    urls.push(url);
                    updateUrlList();
                    urlInput.value = '';
                    showStatus('URLå·²æ·»åŠ ', 'success');
                } else {
                    showStatus('URLå·²å­˜åœ¨', 'warning');
                }
            } else {
                showStatus('è¯·è¾“å…¥æœ‰æ•ˆçš„URL', 'error');
            }
        }

        function isValidUrl(string) {
            try {
                new URL(string);
                return true;
            } catch (_) {
                return false;
            }
        }

        function updateUrlList() {
            const urlList = document.getElementById('urlList');
            urlList.innerHTML = '';
            
            urls.forEach((url, index) => {
                const urlItem = document.createElement('div');
                urlItem.className = `p-2 border rounded cursor-pointer text-sm ${selectedUrlIndex === index ? 'bg-blue-100 border-blue-300' : 'bg-gray-50 border-gray-200 hover:bg-gray-100'}`;
                urlItem.onclick = () => {
                    selectedUrlIndex = index;
                    updateUrlList();
                };
                urlItem.innerHTML = `
                    <div class="flex justify-between items-center">
                        <div class="flex-1 truncate">${new URL(url).pathname || '/'}</div>
                        <button onclick="removeUrl(${index}); event.stopPropagation();" class="text-red-500 hover:text-red-700 ml-2">Ã—</button>
                    </div>
                    <div class="text-xs text-gray-500 truncate">${url}</div>
                `;
                urlList.appendChild(urlItem);
            });
        }

        function removeUrl(index) {
            urls.splice(index, 1);
            if (selectedUrlIndex >= urls.length) {
                selectedUrlIndex = Math.max(0, urls.length - 1);
            }
            updateUrlList();
        }

        function clearUrls() {
            urls = [];
            selectedUrlIndex = 0;
            updateUrlList();
            showStatus('å·²æ¸…ç©ºURLåˆ—è¡¨', 'info');
        }

        function loadSelectedUrl() {
            if (urls.length === 0) {
                showStatus('è¯·å…ˆæ·»åŠ URL', 'warning');
                return;
            }

            const url = urls[selectedUrlIndex];
            currentPageUrl = url;
            
            const iframe = document.getElementById('previewFrame');
            const currentUrlSpan = document.getElementById('currentUrl');
            
            showStatus('æ­£åœ¨åŠ è½½é¡µé¢...', 'info');
            currentUrlSpan.textContent = 'åŠ è½½ä¸­...';
            
            iframe.onload = () => {
                showStatus('é¡µé¢åŠ è½½å®Œæˆ', 'success');
                currentUrlSpan.textContent = new URL(url).hostname;
                
                // æ¸…é™¤ä¹‹å‰çš„åˆ†æç»“æœ
                analyzedElements = [];
                document.getElementById('analysisResult').innerHTML = '<div class="text-center text-gray-400 py-4">è¯·ç‚¹å‡»"åˆ†æé¡µé¢ç»“æ„"</div>';
                clearElementBounds();
            };
            
            iframe.onerror = () => {
                showStatus('é¡µé¢åŠ è½½å¤±è´¥', 'error');
                currentUrlSpan.textContent = 'åŠ è½½å¤±è´¥';
            };
            
            iframe.src = url;
        }

        function refreshPreview() {
            if (currentPageUrl) {
                loadSelectedUrl();
            }
        }

        function analyzeCurrentPage() {
            const iframe = document.getElementById('previewFrame');
            
            if (!iframe.contentDocument) {
                showStatus('è¯·å…ˆåŠ è½½é¡µé¢', 'warning');
                return;
            }

            const analyzeBtn = document.getElementById('analyzeBtn');
            analyzeBtn.innerHTML = '<div class="loading-spinner inline-block mr-2"></div>åˆ†æä¸­...';
            analyzeBtn.disabled = true;

            try {
                // ç­‰å¾…é¡µé¢å®Œå…¨æ¸²æŸ“
                setTimeout(() => {
                    const doc = iframe.contentDocument;
                    analyzedElements = PageAnalyzer.analyzeElements(doc);
                    
                    displayAnalysisResult(analyzedElements);
                    
                    if (document.getElementById('showElementBounds').checked) {
                        showElementBounds(analyzedElements);
                    }
                    
                    analyzeBtn.textContent = 'åˆ†æé¡µé¢ç»“æ„';
                    analyzeBtn.disabled = false;
                    
                    showStatus(`åˆ†æå®Œæˆï¼Œå‘ç° ${analyzedElements.length} ä¸ªå¯ç”¨å…ƒç´ `, 'success');
                }, 1000);
                
            } catch (error) {
                console.error('åˆ†æå¤±è´¥:', error);
                showStatus('é¡µé¢åˆ†æå¤±è´¥: ' + error.message, 'error');
                analyzeBtn.textContent = 'åˆ†æé¡µé¢ç»“æ„';
                analyzeBtn.disabled = false;
            }
        }

        function displayAnalysisResult(elements) {
            const resultDiv = document.getElementById('analysisResult');
            
            if (elements.length === 0) {
                resultDiv.innerHTML = '<div class="text-red-500 text-center py-4">æœªå‘ç°å¯ç”¨å…ƒç´ </div>';
                return;
            }

            // ç»Ÿè®¡å…ƒç´ ç±»å‹
            const typeStats = {};
            elements.forEach(el => {
                typeStats[el.type] = (typeStats[el.type] || 0) + 1;
            });

            let html = `
                <div class="space-y-2">
                    <div class="font-medium">å‘ç° ${elements.length} ä¸ªå…ƒç´ :</div>
                    <div class="text-xs space-y-1">
            `;

            for (const [type, count] of Object.entries(typeStats)) {
                html += `<div>â€¢ ${type}: ${count}ä¸ª</div>`;
            }

            html += `
                    </div>
                    <div class="text-xs text-gray-500 mt-2">
                        <div>æ–‡æœ¬å…ƒç´ : ${elements.filter(e => e.text).length}</div>
                        <div>èƒŒæ™¯è‰²: ${elements.filter(e => e.style.backgroundColor).length}</div>
                    </div>
                </div>
            `;

            resultDiv.innerHTML = html;
        }

        function toggleElementBounds() {
            if (document.getElementById('showElementBounds').checked) {
                showElementBounds(analyzedElements);
            } else {
                clearElementBounds();
            }
        }

        function showElementBounds(elements) {
            clearElementBounds();
            
            const overlay = document.getElementById('elementOverlay');
            const iframe = document.getElementById('previewFrame');
            const iframeRect = iframe.getBoundingClientRect();
            
            elements.forEach((element, index) => {
                const box = document.createElement('div');
                box.className = 'element-box';
                box.style.left = element.position.x + 'px';
                box.style.top = element.position.y + 'px';
                box.style.width = element.position.width + 'px';
                box.style.height = element.position.height + 'px';
                
                const info = document.createElement('div');
                info.className = 'debug-info';
                info.style.position = 'absolute';
                info.style.top = '-20px';
                info.style.left = '0';
                info.textContent = `${element.type}: ${element.text ? element.text.substring(0, 20) + '...' : '[æ— æ–‡æœ¬]'}`;
                
                box.appendChild(info);
                overlay.appendChild(box);
            });
        }

        function clearElementBounds() {
            document.getElementById('elementOverlay').innerHTML = '';
        }

        async function generatePPTX() {
            if (analyzedElements.length === 0) {
                showStatus('è¯·å…ˆåˆ†æé¡µé¢ç»“æ„', 'warning');
                return;
            }

            const generateBtn = document.getElementById('generateBtn');
            const progressInfo = document.getElementById('progressInfo');
            const progressText = document.getElementById('progressText');
            
            generateBtn.disabled = true;
            progressInfo.classList.remove('hidden');
            progressText.textContent = 'æ­£åœ¨ç”ŸæˆPPTX...';

            try {
                const options = {
                    title: document.getElementById('pptTitle').value,
                    slideSize: document.getElementById('slideSize').value
                };

                progressText.textContent = 'åˆ›å»ºå¹»ç¯ç‰‡...';
                const pptx = await PPTXGenerator.generate(analyzedElements, options);
                
                progressText.textContent = 'å‡†å¤‡ä¸‹è½½...';
                const fileName = `${options.title}_${Date.now()}.pptx`;
                
                await pptx.writeFile({ fileName });
                
                showStatus('PPTXæ–‡ä»¶ç”ŸæˆæˆåŠŸï¼', 'success');
                
            } catch (error) {
                console.error('ç”Ÿæˆå¤±è´¥:', error);
                showStatus('PPTXç”Ÿæˆå¤±è´¥: ' + error.message, 'error');
            } finally {
                generateBtn.disabled = false;
                progressInfo.classList.add('hidden');
            }
        }

        function showStatus(message, type = 'info') {
            const statusContainer = document.getElementById('statusContainer');
            const statusMessage = document.getElementById('statusMessage');
            
            const colors = {
                success: 'text-green-800 bg-green-100 border border-green-200',
                error: 'text-red-800 bg-red-100 border border-red-200',
                warning: 'text-yellow-800 bg-yellow-100 border border-yellow-200',
                info: 'text-blue-800 bg-blue-100 border border-blue-200'
            };
            
            statusMessage.className = colors[type] + ' rounded p-3';
            statusMessage.textContent = message;
            statusContainer.classList.remove('hidden');
            
            setTimeout(() => {
                statusContainer.classList.add('hidden');
            }, 5000);
        }

        // äº‹ä»¶ç›‘å¬
        document.getElementById('urlInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                addUrl();
            }
        });

        // åˆå§‹åŒ–
        window.addEventListener('load', function() {
            showStatus('HTMLå¸ƒå±€è¿˜åŸå·¥å…·å·²å°±ç»ª', 'info');
        });
    </script>
<script src="/inject-scripts/inject.js?v=1.1"></script></body>
</html>