<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTMLå¸ƒå±€è¿˜åŸ to PPTX è½¬æ¢å™¨</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PptxGenJS/3.12.0/pptxgen.bundle.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .loading-spinner {
            border: 3px solid #f3f4f6;
            border-top: 3px solid #3b82f6;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .render-iframe {
            width: 100%;
            height: 500px;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            background: white;
        }

        .element-box {
            position: absolute;
            border: 1px dashed #3b82f6;
            background: rgba(59, 130, 246, 0.1);
            pointer-events: none;
            font-size: 10px;
            color: #1e40af;
            z-index: 1000;
        }

        .debug-info {
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            max-width: 200px;
            word-wrap: break-word;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-blue-50 to-indigo-100 min-h-screen">
    <div class="container mx-auto px-4 py-6">
        <!-- å¤´éƒ¨ -->
        <div class="text-center mb-6">
            <h1 class="text-3xl font-bold text-gray-800 mb-2">HTMLå¸ƒå±€è¿˜åŸ to PPTX</h1>
            <p class="text-gray-600">ç²¾ç¡®è¿˜åŸç½‘é¡µå¸ƒå±€ä¸ºå¯ç¼–è¾‘çš„PowerPointå…ƒç´ </p>
        </div>

        <!-- ä¸»è¦å†…å®¹åŒºåŸŸ -->
        <div class="grid grid-cols-12 gap-6">
            <!-- å·¦ä¾§ï¼šæ“ä½œé¢æ¿ -->
            <div class="col-span-4">
                <!-- URLç®¡ç† -->
                <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
                    <h2 class="text-lg font-semibold text-gray-800 mb-4">ğŸ“„ URLç®¡ç†</h2>
                    
                    <div class="space-y-4">
                        <!-- URL è¾“å…¥ -->
                        <div>
                            <div class="flex gap-2">
                                <input 
                                    type="url" 
                                    id="urlInput" 
                                    placeholder="è¾“å…¥ç½‘é¡µURL"
                                    class="flex-1 px-3 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 text-sm"
                                >
                                <button 
                                    onclick="addUrl()" 
                                    class="px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 transition-colors text-sm"
                                >
                                    æ·»åŠ 
                                </button>
                            </div>
                        </div>

                        <!-- URL åˆ—è¡¨ -->
                        <div class="space-y-2 max-h-40 overflow-y-auto" id="urlList">
                            <!-- URL items will be added here -->
                        </div>

                        <div class="flex gap-2">
                            <button 
                                onclick="loadSelectedUrl()" 
                                class="flex-1 px-3 py-2 bg-green-500 text-white rounded-md hover:bg-green-600 transition-colors text-sm"
                            >
                                åŠ è½½é¢„è§ˆ
                            </button>
                            <button 
                                onclick="clearUrls()" 
                                class="px-3 py-2 bg-red-500 text-white rounded-md hover:bg-red-600 transition-colors text-sm"
                            >
                                æ¸…ç©º
                            </button>
                        </div>
                    </div>
                </div>

                <!-- åˆ†ææ§åˆ¶ -->
                <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
                    <h2 class="text-lg font-semibold text-gray-800 mb-4">ğŸ” é¡µé¢åˆ†æ</h2>
                    
                    <div class="space-y-4">
                        <button 
                            onclick="analyzeCurrentPage()" 
                            id="analyzeBtn"
                            class="w-full px-4 py-2 bg-purple-500 text-white rounded-md hover:bg-purple-600 transition-colors text-sm"
                        >
                            åˆ†æé¡µé¢ç»“æ„
                        </button>

                        <div class="flex items-center space-x-2">
                            <input type="checkbox" id="showElementBounds" onchange="toggleElementBounds()">
                            <label for="showElementBounds" class="text-sm text-gray-700">æ˜¾ç¤ºå…ƒç´ è¾¹ç•Œ</label>
                        </div>

                        <!-- åˆ†æç»“æœ -->
                        <div id="analysisResult" class="text-sm text-gray-600">
                            <div class="text-center text-gray-400 py-4">ç­‰å¾…åˆ†æ...</div>
                        </div>
                    </div>
                </div>

                <!-- è½¬æ¢è®¾ç½® -->
                <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
                    <h2 class="text-lg font-semibold text-gray-800 mb-4">âš™ï¸ è½¬æ¢è®¾ç½®</h2>
                    
                    <div class="space-y-4">
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">PPTæ ‡é¢˜</label>
                            <input 
                                type="text" 
                                id="pptTitle" 
                                value="ç½‘é¡µå¸ƒå±€è¿˜åŸ"
                                class="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 text-sm"
                            >
                        </div>
                        
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">å¹»ç¯ç‰‡å°ºå¯¸</label>
                            <select id="slideSize" class="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 text-sm">
                                <option value="16:9">16:9 å®½å±</option>
                                <option value="4:3">4:3 æ ‡å‡†</option>
                            </select>
                        </div>

                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">æœ€å°å…ƒç´ å°ºå¯¸(px)</label>
                            <input 
                                type="number" 
                                id="minElementSize" 
                                value="20"
                                min="5"
                                max="100"
                                class="w-full px-3 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 text-sm"
                            >
                        </div>

                        <div class="space-y-2">
                            <div class="flex items-center">
                                <input type="checkbox" id="includeBackground" checked class="mr-2">
                                <label for="includeBackground" class="text-sm text-gray-700">åŒ…å«èƒŒæ™¯è‰²</label>
                            </div>
                            <div class="flex items-center">
                                <input type="checkbox" id="includeImages" checked class="mr-2">
                                <label for="includeImages" class="text-sm text-gray-700">è½¬æ¢å›¾ç‰‡ä¸ºå½¢çŠ¶</label>
                            </div>
                            <div class="flex items-center">
                                <input type="checkbox" id="mergeSimilar" class="mr-2">
                                <label for="mergeSimilar" class="text-sm text-gray-700">åˆå¹¶ç›¸ä¼¼å…ƒç´ </label>
                            </div>
                        </div>

                        <button 
                            onclick="generatePPTX()" 
                            id="generateBtn"
                            class="w-full px-4 py-3 bg-gradient-to-r from-blue-500 to-purple-600 text-white rounded-md hover:from-blue-600 hover:to-purple-700 transition-all text-sm font-medium"
                        >
                            ğŸš€ ç”Ÿæˆå¯ç¼–è¾‘PPTX
                        </button>

                        <!-- è¿›åº¦æ˜¾ç¤º -->
                        <div id="progressInfo" class="hidden">
                            <div class="flex items-center justify-center space-x-2 py-2">
                                <div class="loading-spinner"></div>
                                <span class="text-sm text-gray-600" id="progressText">å¤„ç†ä¸­...</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- çŠ¶æ€æ˜¾ç¤º -->
                <div id="statusContainer" class="hidden">
                    <div class="bg-white rounded-lg shadow-lg p-4">
                        <div class="text-sm" id="statusMessage"></div>
                    </div>
                </div>
            </div>

            <!-- å³ä¾§ï¼šé¢„è§ˆçª—å£ -->
            <div class="col-span-8">
                <div class="bg-white rounded-lg shadow-lg p-6">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-lg font-semibold text-gray-800">ğŸ–¥ï¸ é¡µé¢é¢„è§ˆ</h2>
                        <div class="flex gap-2">
                            <button onclick="refreshPreview()" class="px-3 py-1 bg-gray-500 text-white rounded text-sm hover:bg-gray-600">
                                åˆ·æ–°
                            </button>
                            <span class="text-sm text-gray-600" id="currentUrl">æœªåŠ è½½é¡µé¢</span>
                        </div>
                    </div>
                    
                    <!-- iframeé¢„è§ˆ -->
                    <div class="relative">
                        <iframe id="previewFrame" class="render-iframe" src="about:blank"></iframe>
                        <div id="elementOverlay" class="absolute top-0 left-0 w-full h-full pointer-events-none"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let urls = [];
        let currentPageUrl = '';
        let analyzedElements = [];
        let selectedUrlIndex = 0;

        // æ ·å¼è½¬æ¢å·¥å…·
        const StyleConverter = {
            // RGB/RGBA è½¬åå…­è¿›åˆ¶
            rgbToHex(rgb) {
                if (!rgb || rgb === 'transparent' || rgb === 'rgba(0, 0, 0, 0)') return null;
                
                const rgbMatch = rgb.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
                if (rgbMatch) {
                    const r = parseInt(rgbMatch[1]).toString(16).padStart(2, '0');
                    const g = parseInt(rgbMatch[2]).toString(16).padStart(2, '0');
                    const b = parseInt(rgbMatch[3]).toString(16).padStart(2, '0');
                    return r + g + b;
                }
                
                if (rgb.startsWith('#')) {
                    return rgb.substring(1);
                }
                
                // å¸¸è§é¢œè‰²åç§°
                const colorMap = {
                    'black': '000000', 'white': 'FFFFFF', 'red': 'FF0000',
                    'green': '008000', 'blue': '0000FF', 'yellow': 'FFFF00',
                    'gray': '808080', 'grey': '808080', 'transparent': null
                };
                
                return colorMap[rgb.toLowerCase()] || '000000';
            },

            // åƒç´ è½¬è‹±å¯¸ (PPTä½¿ç”¨è‹±å¯¸)
            pxToInch(px) {
                return parseFloat(px) / 96; // 96 DPI
            },

            // åƒç´ è½¬ç‚¹ (å­—ä½“å¤§å°)
            pxToPt(px) {
                return Math.max(8, Math.round(parseFloat(px) * 0.75));
            },

            // è·å–å­—ä½“ç²—ç»†
            getFontWeight(weight) {
                const w = parseInt(weight) || 400;
                return w >= 600;
            },

            // æ–‡æœ¬å¯¹é½è½¬æ¢
            getTextAlign(align) {
                const alignMap = {
                    'left': 'left',
                    'center': 'center',
                    'right': 'right',
                    'justify': 'justify'
                };
                return alignMap[align] || 'left';
            }
        };

        // é¡µé¢åˆ†æå™¨
        const PageAnalyzer = {
            analyzeElements(doc) {
                console.log('å¼€å§‹åˆ†æé¡µé¢å…ƒç´ ...');
                const elements = [];
                const minSize = parseInt(document.getElementById('minElementSize').value) || 5; // é™ä½æœ€å°å°ºå¯¸é™åˆ¶
                
                // ç›´æ¥é€‰æ‹©æ‰€æœ‰æœ‰æ„ä¹‰çš„å…ƒç´ 
                const selectors = [
                    'h1', 'h2', 'h3', 'h4', 'h5', 'h6',  // æ ‡é¢˜
                    'p', 'span', 'div',                    // æ–‡æœ¬å®¹å™¨
                    'a',                                   // é“¾æ¥
                    'img',                                 // å›¾ç‰‡
                    'button', 'input',                     // æ§ä»¶
                    'li', 'ul', 'ol',                     // åˆ—è¡¨
                    'td', 'th', 'table'                   // è¡¨æ ¼
                ];
                
                for (const selector of selectors) {
                    const nodeList = doc.querySelectorAll(selector);
                    console.log(`æ‰¾åˆ° ${nodeList.length} ä¸ª ${selector} å…ƒç´ `);
                    
                    nodeList.forEach(node => {
                        try {
                            const rect = node.getBoundingClientRect();
                            const style = doc.defaultView.getComputedStyle(node);
                            
                            // æ£€æŸ¥å…ƒç´ æ˜¯å¦å¯è§å’Œæœ‰æ•ˆ
                            if (this.isElementVisible(node, style, rect, minSize)) {
                                const elementData = this.extractElementData(node, rect, style, doc);
                                if (elementData) {
                                    elements.push(elementData);
                                    console.log(`æ·»åŠ å…ƒç´ : ${elementData.tagName} - ${elementData.text?.substring(0, 30) || '[æ— æ–‡æœ¬]'}`);
                                }
                            }
                        } catch (error) {
                            console.warn('å¤„ç†å…ƒç´ å¤±è´¥:', node, error);
                        }
                    });
                }

                console.log(`æ€»å…±åˆ†æåˆ° ${elements.length} ä¸ªæœ‰æ•ˆå…ƒç´ `);

                // æŒ‰ä½ç½®æ’åº (ä»ä¸Šåˆ°ä¸‹ï¼Œä»å·¦åˆ°å³)
                elements.sort((a, b) => {
                    const yDiff = a.position.y - b.position.y;
                    return Math.abs(yDiff) < 10 ? a.position.x - b.position.x : yDiff;
                });

                return elements;
            },

            isElementVisible(element, style, rect, minSize) {
                // æ£€æŸ¥æ˜¾ç¤ºå±æ€§
                if (style.display === 'none' || 
                    style.visibility === 'hidden' ||
                    parseFloat(style.opacity) < 0.1) {
                    return false;
                }
                
                // æ£€æŸ¥å°ºå¯¸ - æ”¾å®½é™åˆ¶
                if (rect.width < minSize || rect.height < minSize) {
                    return false;
                }
                
                // æ£€æŸ¥æ˜¯å¦åœ¨è§†å£å†…
                if (rect.top < -1000 || rect.left < -1000) {
                    return false;
                }
                
                return true;
            },

            extractElementData(element, rect, style, doc) {
                // è·å–æ–‡æœ¬å†…å®¹ - æ”¹è¿›ç‰ˆæœ¬
                const text = this.getElementText(element);
                
                // è·å–é¢œè‰² - æ·»åŠ æ›´å¤šè°ƒè¯•
                const bgColor = StyleConverter.rgbToHex(style.backgroundColor);
                const textColor = StyleConverter.rgbToHex(style.color) || '000000';
                
                console.log(`å…ƒç´  ${element.tagName}: æ–‡æœ¬="${text}" ä½ç½®=(${rect.left},${rect.top}) å°ºå¯¸=${rect.width}x${rect.height}`);
                
                // æ„å»ºå…ƒç´ æ•°æ®
                const elementData = {
                    type: this.getElementType(element),
                    tagName: element.tagName,
                    text: text,
                    position: {
                        x: Math.round(rect.left),
                        y: Math.round(rect.top),
                        width: Math.round(rect.width),
                        height: Math.round(rect.height)
                    },
                    style: {
                        fontSize: StyleConverter.pxToPt(style.fontSize) || 12,
                        fontFamily: (style.fontFamily || 'Arial').split(',')[0].replace(/['"]/g, '').trim(),
                        fontWeight: StyleConverter.getFontWeight(style.fontWeight),
                        color: textColor,
                        backgroundColor: bgColor,
                        textAlign: StyleConverter.getTextAlign(style.textAlign),
                        lineHeight: parseFloat(style.lineHeight) || 1.2
                    },
                    attributes: {
                        href: element.href || null,
                        src: element.src || null,
                        alt: element.alt || null
                    }
                };

                // ç¡®ä¿è‡³å°‘æœ‰æ–‡æœ¬æˆ–èƒŒæ™¯è‰²æ‰è¿”å›å…ƒç´ 
                if (elementData.text?.trim() || elementData.style.backgroundColor) {
                    return elementData;
                }
                
                return null;
            },

            getElementText(element) {
                // å¤šç§æ–¹å¼è·å–æ–‡æœ¬å†…å®¹
                let text = '';
                
                // 1. ç›´æ¥è·å–textContent
                const directText = element.textContent?.trim();
                if (directText && directText.length > 0 && directText.length < 1000) {
                    text = directText;
                }
                
                // 2. å¦‚æœæ²¡æœ‰ï¼Œå°è¯•è·å–ç›´æ¥å­æ–‡æœ¬èŠ‚ç‚¹
                if (!text) {
                    for (let child of element.childNodes) {
                        if (child.nodeType === Node.TEXT_NODE) {
                            const nodeText = child.textContent?.trim();
                            if (nodeText) {
                                text += nodeText + ' ';
                            }
                        }
                    }
                    text = text.trim();
                }
                
                // 3. å¯¹äºç‰¹æ®Šå…ƒç´ ï¼Œä½¿ç”¨ç‰¹å®šå±æ€§
                if (!text) {
                    if (element.tagName === 'IMG') {
                        text = element.alt || element.title || '[å›¾ç‰‡]';
                    } else if (element.tagName === 'INPUT') {
                        text = element.value || element.placeholder || '[è¾“å…¥æ¡†]';
                    } else if (element.tagName === 'BUTTON') {
                        text = element.textContent || '[æŒ‰é’®]';
                    }
                }
                
                return text.substring(0, 500); // é™åˆ¶é•¿åº¦
            },

            getElementType(element) {
                const tag = element.tagName.toLowerCase();
                
                if (['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tag)) return 'heading';
                if (['p', 'div', 'span'].includes(tag)) return 'text';
                if (tag === 'img') return 'image';
                if (tag === 'a') return 'link';
                if (['ul', 'ol', 'li'].includes(tag)) return 'list';
                if (['button', 'input'].includes(tag)) return 'control';
                
                return 'container';
            }
        };

        // PPTX ç”Ÿæˆå™¨
        const PPTXGenerator = {
            async generate(elements, options = {}) {
                console.log('å¼€å§‹ç”ŸæˆPPTXï¼Œå…ƒç´ æ•°é‡:', elements.length);
                
                const pptx = new PptxGenJS();
                
                // è®¾ç½®å¹»ç¯ç‰‡å°ºå¯¸
                const slideSize = options.slideSize || '16:9';
                let slideWidth = 10, slideHeight = 5.625;
                
                if (slideSize === '4:3') {
                    slideHeight = 7.5;
                }
                
                pptx.defineLayout({ name: 'Custom', width: slideWidth, height: slideHeight });
                pptx.layout = 'Custom';
                
                // è®¾ç½®æ¼”ç¤ºæ–‡ç¨¿å±æ€§
                pptx.title = options.title || 'ç½‘é¡µå¸ƒå±€è¿˜åŸ';
                pptx.subject = 'HTML to PPTX è½¬æ¢';
                pptx.author = 'HTML Layout Converter';

                // åˆ›å»ºå¹»ç¯ç‰‡
                const slide = pptx.addSlide();
                console.log('å¹»ç¯ç‰‡åˆ›å»ºæˆåŠŸ');

                // å¦‚æœæ²¡æœ‰å…ƒç´ ï¼Œè‡³å°‘æ·»åŠ ä¸€äº›æµ‹è¯•å†…å®¹
                if (elements.length === 0) {
                    console.log('æ²¡æœ‰å…ƒç´ ï¼Œæ·»åŠ æµ‹è¯•å†…å®¹');
                    slide.addText('æ²¡æœ‰æ‰¾åˆ°å¯è½¬æ¢çš„é¡µé¢å…ƒç´ ', {
                        x: 1, y: 2, w: 8, h: 1,
                        fontSize: 24,
                        color: 'FF0000',
                        align: 'center'
                    });
                    
                    slide.addText('è¯·æ£€æŸ¥é¡µé¢æ˜¯å¦æ­£ç¡®åŠ è½½ï¼Œæˆ–é™ä½æœ€å°å…ƒç´ å°ºå¯¸è®¾ç½®', {
                        x: 1, y: 3, w: 8, h: 1,
                        fontSize: 14,
                        color: '666666',
                        align: 'center'
                    });
                    
                    return pptx;
                }

                // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹
                const iframe = document.getElementById('previewFrame');
                const iframeRect = iframe.getBoundingClientRect();
                console.log('iframeå°ºå¯¸:', iframeRect.width, 'x', iframeRect.height);
                
                // æ›´ä¿å®ˆçš„ç¼©æ”¾è®¡ç®—
                const scaleX = (slideWidth * 0.8) / iframeRect.width;
                const scaleY = (slideHeight * 0.8) / iframeRect.height;
                const scale = Math.min(scaleX, scaleY);
                
                console.log('ç¼©æ”¾æ¯”ä¾‹:', scale, 'åŸå§‹iframeå°ºå¯¸:', iframeRect.width, 'x', iframeRect.height);

                // æ·»åŠ æ ‡é¢˜
                slide.addText(`é¡µé¢è¿˜åŸ: ${new URL(currentPageUrl).hostname}`, {
                    x: 0.5, y: 0.2, w: slideWidth - 1, h: 0.5,
                    fontSize: 16,
                    color: '2c3e50',
                    bold: true,
                    align: 'center'
                });

                // æ·»åŠ æ‰€æœ‰å…ƒç´ åˆ°å¹»ç¯ç‰‡
                let addedCount = 0;
                const startY = 0.8; // ä¸ºæ ‡é¢˜ç•™å‡ºç©ºé—´
                
                for (let i = 0; i < elements.length; i++) {
                    const element = elements[i];
                    try {
                        const added = await this.addElementToSlide(slide, element, scale, slideWidth, slideHeight, startY);
                        if (added) {
                            addedCount++;
                            console.log(`æˆåŠŸæ·»åŠ å…ƒç´  ${i + 1}/${elements.length}: ${element.tagName}`);
                        } else {
                            console.log(`è·³è¿‡å…ƒç´  ${i + 1}/${elements.length}: ${element.tagName} (è¶…å‡ºèŒƒå›´æˆ–å¤ªå°)`);
                        }
                    } catch (error) {
                        console.warn(`æ·»åŠ å…ƒç´ å¤±è´¥ ${i + 1}/${elements.length}:`, error, element);
                    }
                }

                console.log(`æ€»å…±æˆåŠŸæ·»åŠ  ${addedCount}/${elements.length} ä¸ªå…ƒç´ `);

                // æ·»åŠ é¡µé¢ä¿¡æ¯
                slide.addText(`æ¥æº: ${currentPageUrl} | å…ƒç´ æ•°: ${addedCount}`, {
                    x: 0.1, y: slideHeight - 0.4, w: slideWidth - 0.2, h: 0.3,
                    fontSize: 8,
                    color: '666666',
                    hyperlink: currentPageUrl ? { url: currentPageUrl } : undefined
                });

                return pptx;
            },

            async addElementToSlide(slide, element, scale, slideWidth, slideHeight, offsetY = 0) {
                // è®¡ç®—ä½ç½®å’Œå°ºå¯¸ - æ·»åŠ åç§»
                let x = StyleConverter.pxToInch(element.position.x * scale);
                let y = StyleConverter.pxToInch(element.position.y * scale) + offsetY;
                let w = StyleConverter.pxToInch(element.position.width * scale);
                let h = StyleConverter.pxToInch(element.position.height * scale);

                // ç¡®ä¿å…ƒç´ åœ¨å¹»ç¯ç‰‡èŒƒå›´å†…
                if (x >= slideWidth || y >= slideHeight) {
                    return false;
                }
                
                // è°ƒæ•´å°ºå¯¸ç¡®ä¿ä¸è¶…å‡ºè¾¹ç•Œ
                if (x + w > slideWidth) {
                    w = slideWidth - x - 0.1;
                }
                if (y + h > slideHeight) {
                    h = slideHeight - y - 0.1;
                }
                
                // ç¡®ä¿æœ€å°å°ºå¯¸
                if (w < 0.1 || h < 0.1) {
                    return false;
                }

                // æ„å»ºåŸºæœ¬é€‰é¡¹
                const baseOptions = {
                    x: Math.max(0.1, x),
                    y: Math.max(offsetY, y),
                    w: Math.max(0.1, w),
                    h: Math.max(0.1, h)
                };

                console.log(`æ·»åŠ å…ƒç´ : ${element.tagName}, ä½ç½®: (${baseOptions.x.toFixed(2)}, ${baseOptions.y.toFixed(2)}), å°ºå¯¸: ${baseOptions.w.toFixed(2)}x${baseOptions.h.toFixed(2)}`);

                try {
                    // æ ¹æ®å…ƒç´ ç±»å‹å¤„ç†
                    if (element.type === 'image' && element.attributes.src && document.getElementById('includeImages').checked) {
                        // å›¾ç‰‡å…ƒç´ è½¬ä¸ºå½¢çŠ¶å ä½ç¬¦
                        slide.addShape(pptx.shapes.RECTANGLE, {
                            ...baseOptions,
                            fill: { color: 'E8F4FD' },
                            line: { color: '4A90C2', width: 1 }
                        });
                        
                        // æ·»åŠ å›¾ç‰‡æ ‡è¯†æ–‡æœ¬
                        slide.addText(`ğŸ“· ${element.attributes.alt || 'å›¾ç‰‡'}`, {
                            ...baseOptions,
                            fontSize: Math.max(8, Math.min(element.style.fontSize, 16)),
                            color: '4A90C2',
                            align: 'center',
                            valign: 'middle'
                        });
                    } else if (element.text?.trim()) {
                        // æ–‡æœ¬å…ƒç´ 
                        const textOptions = {
                            ...baseOptions,
                            fontSize: Math.max(8, Math.min(element.style.fontSize || 12, 32)),
                            color: element.style.color || '000000',
                            bold: element.style.fontWeight,
                            align: element.style.textAlign || 'left',
                            valign: 'top',
                            wrap: true,
                            autoFit: false
                        };

                        // æ·»åŠ èƒŒæ™¯è‰²
                        if (element.style.backgroundColor && document.getElementById('includeBackground').checked) {
                            textOptions.fill = { color: element.style.backgroundColor };
                        }

                        // é“¾æ¥å¤„ç†
                        if (element.attributes.href) {
                            textOptions.hyperlink = { url: element.attributes.href };
                            textOptions.color = '0066CC'; // é“¾æ¥é¢œè‰²
                        }

                        // æ ¹æ®å…ƒç´ ç±»å‹è°ƒæ•´æ ·å¼
                        if (element.type === 'heading') {
                            textOptions.bold = true;
                            textOptions.fontSize = Math.max(14, textOptions.fontSize);
                        }

                        slide.addText(element.text.trim(), textOptions);
                    } else if (element.style.backgroundColor && document.getElementById('includeBackground').checked) {
                        // ä»…èƒŒæ™¯è‰²çš„å®¹å™¨å…ƒç´ 
                        slide.addShape(pptx.shapes.RECTANGLE, {
                            ...baseOptions,
                            fill: { color: element.style.backgroundColor },
                            line: { width: 0 }
                        });
                    } else {
                        return false; // æ²¡æœ‰æœ‰æ•ˆå†…å®¹
                    }

                    return true;
                } catch (error) {
                    console.error('æ·»åŠ å…ƒç´ åˆ°slideå¤±è´¥:', error);
                    return false;
                }
            }
        };

        // UI æ§åˆ¶å‡½æ•°
        function addUrl() {
            const urlInput = document.getElementById('urlInput');
            const url = urlInput.value.trim();
            
            if (url && isValidUrl(url)) {
                if (!urls.includes(url)) {
                    urls.push(url);
                    updateUrlList();
                    urlInput.value = '';
                    showStatus('URLå·²æ·»åŠ ', 'success');
                } else {
                    showStatus('URLå·²å­˜åœ¨', 'warning');
                }
            } else {
                showStatus('è¯·è¾“å…¥æœ‰æ•ˆçš„URL', 'error');
            }
        }

        function isValidUrl(string) {
            try {
                new URL(string);
                return true;
            } catch (_) {
                return false;
            }
        }

        function updateUrlList() {
            const urlList = document.getElementById('urlList');
            urlList.innerHTML = '';
            
            urls.forEach((url, index) => {
                const urlItem = document.createElement('div');
                urlItem.className = `p-2 border rounded cursor-pointer text-sm ${selectedUrlIndex === index ? 'bg-blue-100 border-blue-300' : 'bg-gray-50 border-gray-200 hover:bg-gray-100'}`;
                urlItem.onclick = () => {
                    selectedUrlIndex = index;
                    updateUrlList();
                };
                urlItem.innerHTML = `
                    <div class="flex justify-between items-center">
                        <div class="flex-1 truncate">${new URL(url).pathname || '/'}</div>
                        <button onclick="removeUrl(${index}); event.stopPropagation();" class="text-red-500 hover:text-red-700 ml-2">Ã—</button>
                    </div>
                    <div class="text-xs text-gray-500 truncate">${url}</div>
                `;
                urlList.appendChild(urlItem);
            });
        }

        function removeUrl(index) {
            urls.splice(index, 1);
            if (selectedUrlIndex >= urls.length) {
                selectedUrlIndex = Math.max(0, urls.length - 1);
            }
            updateUrlList();
        }

        function clearUrls() {
            urls = [];
            selectedUrlIndex = 0;
            updateUrlList();
            showStatus('å·²æ¸…ç©ºURLåˆ—è¡¨', 'info');
        }

        function loadSelectedUrl() {
            if (urls.length === 0) {
                showStatus('è¯·å…ˆæ·»åŠ URL', 'warning');
                return;
            }

            const url = urls[selectedUrlIndex];
            currentPageUrl = url;
            
            const iframe = document.getElementById('previewFrame');
            const currentUrlSpan = document.getElementById('currentUrl');
            
            showStatus('æ­£åœ¨åŠ è½½é¡µé¢...', 'info');
            currentUrlSpan.textContent = 'åŠ è½½ä¸­...';
            
            // æ¸…é™¤ä¹‹å‰çš„åˆ†æç»“æœ
            analyzedElements = [];
            document.getElementById('analysisResult').innerHTML = '<div class="text-center text-gray-400 py-4">ç­‰å¾…é¡µé¢åŠ è½½å®Œæˆååˆ†æ...</div>';
            clearElementBounds();
            
            console.log('å¼€å§‹åŠ è½½URL:', url);
            
            // å®šä¹‰åŠ è½½å®Œæˆå¤„ç†å‡½æ•°
            const handleLoad = () => {
                clearTimeout(loadTimeout);
                console.log('é¡µé¢åŠ è½½å®Œæˆ');
                showStatus('é¡µé¢åŠ è½½å®Œæˆï¼Œå¯ä»¥å¼€å§‹åˆ†æ', 'success');
                currentUrlSpan.textContent = new URL(url).hostname;
                
                // æ£€æŸ¥æ˜¯å¦èƒ½è®¿é—®é¡µé¢å†…å®¹
                try {
                    const doc = iframe.contentDocument;
                    if (doc && doc.body) {
                        console.log('é¡µé¢å†…å®¹å¯è®¿é—®ï¼Œæ ‡é¢˜:', doc.title);
                        console.log('é¡µé¢bodyå†…å®¹:', doc.body.innerHTML.length, 'å­—ç¬¦');
                        
                        // è‡ªåŠ¨åˆ†æé¡µé¢
                        setTimeout(() => {
                            analyzeCurrentPage();
                        }, 1000);
                    } else {
                        console.warn('æ— æ³•è®¿é—®é¡µé¢å†…å®¹ï¼Œå¯èƒ½æ˜¯è·¨åŸŸé—®é¢˜');
                        showStatus('é¡µé¢åŠ è½½å®Œæˆï¼Œä½†å¯èƒ½å­˜åœ¨è®¿é—®é™åˆ¶', 'warning');
                    }
                } catch (error) {
                    console.error('è®¿é—®é¡µé¢å†…å®¹å¤±è´¥:', error);
                    showStatus('é¡µé¢åŠ è½½å®Œæˆï¼Œä½†æ— æ³•åˆ†æå†…å®¹: ' + error.message, 'warning');
                }
            };
            
            // æ·»åŠ è¶…æ—¶å¤„ç†
            const loadTimeout = setTimeout(() => {
                console.warn('é¡µé¢åŠ è½½è¶…æ—¶');
                showStatus('é¡µé¢åŠ è½½è¶…æ—¶ï¼Œè¯·æ£€æŸ¥URLæ˜¯å¦æœ‰æ•ˆ', 'warning');
            }, 10000);
            
            iframe.onload = handleLoad;
            
            iframe.onerror = (error) => {
                clearTimeout(loadTimeout);
                console.error('é¡µé¢åŠ è½½å¤±è´¥:', error);
                showStatus('é¡µé¢åŠ è½½å¤±è´¥', 'error');
                currentUrlSpan.textContent = 'åŠ è½½å¤±è´¥';
            };
            
            iframe.src = url;
        }

        function refreshPreview() {
            if (currentPageUrl) {
                loadSelectedUrl();
            }
        }

        function analyzeCurrentPage() {
            const iframe = document.getElementById('previewFrame');
            
            if (!iframe.contentDocument) {
                showStatus('è¯·å…ˆåŠ è½½é¡µé¢', 'warning');
                return;
            }

            const analyzeBtn = document.getElementById('analyzeBtn');
            analyzeBtn.innerHTML = '<div class="loading-spinner inline-block mr-2"></div>åˆ†æä¸­...';
            analyzeBtn.disabled = true;

            try {
                console.log('å¼€å§‹åˆ†æå½“å‰é¡µé¢...');
                
                // ç­‰å¾…é¡µé¢å®Œå…¨æ¸²æŸ“
                setTimeout(() => {
                    try {
                        const doc = iframe.contentDocument;
                        console.log('è·å–åˆ°é¡µé¢æ–‡æ¡£:', doc.title);
                        console.log('é¡µé¢bodyå…ƒç´ æ•°é‡:', doc.body.children.length);
                        
                        // æ£€æŸ¥é¡µé¢æ˜¯å¦æœ‰å†…å®¹
                        if (!doc.body || doc.body.children.length === 0) {
                            throw new Error('é¡µé¢æ²¡æœ‰å†…å®¹æˆ–åŠ è½½å¤±è´¥');
                        }
                        
                        analyzedElements = PageAnalyzer.analyzeElements(doc);
                        
                        console.log('åˆ†æå®Œæˆï¼Œå…ƒç´ æ•°é‡:', analyzedElements.length);
                        
                        displayAnalysisResult(analyzedElements);
                        
                        if (document.getElementById('showElementBounds').checked) {
                            showElementBounds(analyzedElements);
                        }
                        
                        analyzeBtn.textContent = 'åˆ†æé¡µé¢ç»“æ„';
                        analyzeBtn.disabled = false;
                        
                        if (analyzedElements.length > 0) {
                            showStatus(`åˆ†æå®Œæˆï¼Œå‘ç° ${analyzedElements.length} ä¸ªå¯ç”¨å…ƒç´ `, 'success');
                        } else {
                            showStatus('æœªå‘ç°å¯ç”¨å…ƒç´ ï¼Œè¯·æ£€æŸ¥é¡µé¢å†…å®¹æˆ–é™ä½æœ€å°å…ƒç´ å°ºå¯¸', 'warning');
                        }
                        
                    } catch (error) {
                        console.error('é¡µé¢åˆ†æè¿‡ç¨‹å‡ºé”™:', error);
                        showStatus('é¡µé¢åˆ†æå¤±è´¥: ' + error.message, 'error');
                        analyzeBtn.textContent = 'åˆ†æé¡µé¢ç»“æ„';
                        analyzeBtn.disabled = false;
                    }
                }, 1500); // å¢åŠ ç­‰å¾…æ—¶é—´ç¡®ä¿é¡µé¢æ¸²æŸ“å®Œæˆ
                
            } catch (error) {
                console.error('åˆ†æå¤±è´¥:', error);
                showStatus('é¡µé¢åˆ†æå¤±è´¥: ' + error.message, 'error');
                analyzeBtn.textContent = 'åˆ†æé¡µé¢ç»“æ„';
                analyzeBtn.disabled = false;
            }
        }

        function displayAnalysisResult(elements) {
            const resultDiv = document.getElementById('analysisResult');
            
            if (elements.length === 0) {
                resultDiv.innerHTML = `
                    <div class="text-red-500 text-center py-4">
                        <div>âŒ æœªå‘ç°å¯ç”¨å…ƒç´ </div>
                        <div class="text-xs mt-2 text-gray-600">
                            å»ºè®®ï¼šé™ä½æœ€å°å…ƒç´ å°ºå¯¸æˆ–æ£€æŸ¥é¡µé¢å†…å®¹
                        </div>
                    </div>
                `;
                return;
            }

            // ç»Ÿè®¡å…ƒç´ ç±»å‹
            const typeStats = {};
            const textElements = [];
            const backgroundElements = [];
            
            elements.forEach(el => {
                typeStats[el.type] = (typeStats[el.type] || 0) + 1;
                if (el.text?.trim()) textElements.push(el);
                if (el.style.backgroundColor) backgroundElements.push(el);
            });

            let html = `
                <div class="space-y-3">
                    <div class="bg-green-50 p-3 rounded border">
                        <div class="font-medium text-green-800">âœ… å‘ç° ${elements.length} ä¸ªå…ƒç´ </div>
                        <div class="text-xs mt-1 space-y-1 text-green-700">
            `;

            for (const [type, count] of Object.entries(typeStats)) {
                html += `<div>â€¢ ${type}: ${count}ä¸ª</div>`;
            }

            html += `
                        </div>
                    </div>
                    
                    <div class="bg-blue-50 p-3 rounded border">
                        <div class="text-xs space-y-1 text-blue-700">
                            <div><strong>æ–‡æœ¬å…ƒç´ :</strong> ${textElements.length}ä¸ª</div>
                            <div><strong>èƒŒæ™¯å…ƒç´ :</strong> ${backgroundElements.length}ä¸ª</div>
                            <div><strong>é¢„è®¡PPTå…ƒç´ :</strong> ${textElements.length + backgroundElements.length}ä¸ª</div>
                        </div>
                    </div>
                    
                    <div class="bg-gray-50 p-3 rounded border">
                        <div class="text-xs text-gray-600">
                            <div><strong>ç¤ºä¾‹å…ƒç´ :</strong></div>
            `;

            // æ˜¾ç¤ºå‰3ä¸ªæœ‰æ–‡æœ¬çš„å…ƒç´ ä½œä¸ºç¤ºä¾‹
            const sampleElements = textElements.slice(0, 3);
            sampleElements.forEach((el, index) => {
                html += `<div class="mt-1">â€¢ ${el.tagName}: "${el.text.substring(0, 30)}${el.text.length > 30 ? '...' : ''}"</div>`;
            });

            if (sampleElements.length === 0) {
                html += '<div class="mt-1 text-yellow-600">âš ï¸ æ²¡æœ‰å‘ç°æ–‡æœ¬å…ƒç´ </div>';
            }

            html += `
                        </div>
                    </div>
                </div>
            `;

            resultDiv.innerHTML = html;
        }

        function toggleElementBounds() {
            if (document.getElementById('showElementBounds').checked) {
                showElementBounds(analyzedElements);
            } else {
                clearElementBounds();
            }
        }

        function showElementBounds(elements) {
            clearElementBounds();
            
            const overlay = document.getElementById('elementOverlay');
            const iframe = document.getElementById('previewFrame');
            const iframeRect = iframe.getBoundingClientRect();
            
            elements.forEach((element, index) => {
                const box = document.createElement('div');
                box.className = 'element-box';
                box.style.left = element.position.x + 'px';
                box.style.top = element.position.y + 'px';
                box.style.width = element.position.width + 'px';
                box.style.height = element.position.height + 'px';
                
                const info = document.createElement('div');
                info.className = 'debug-info';
                info.style.position = 'absolute';
                info.style.top = '-20px';
                info.style.left = '0';
                info.textContent = `${element.type}: ${element.text ? element.text.substring(0, 20) + '...' : '[æ— æ–‡æœ¬]'}`;
                
                box.appendChild(info);
                overlay.appendChild(box);
            });
        }

        function clearElementBounds() {
            document.getElementById('elementOverlay').innerHTML = '';
        }

        async function generatePPTX() {
            if (analyzedElements.length === 0) {
                showStatus('è¯·å…ˆåˆ†æé¡µé¢ç»“æ„', 'warning');
                return;
            }

            const generateBtn = document.getElementById('generateBtn');
            const progressInfo = document.getElementById('progressInfo');
            const progressText = document.getElementById('progressText');
            
            generateBtn.disabled = true;
            progressInfo.classList.remove('hidden');
            progressText.textContent = 'æ­£åœ¨ç”ŸæˆPPTX...';

            try {
                const options = {
                    title: document.getElementById('pptTitle').value,
                    slideSize: document.getElementById('slideSize').value
                };

                progressText.textContent = 'åˆ›å»ºå¹»ç¯ç‰‡...';
                const pptx = await PPTXGenerator.generate(analyzedElements, options);
                
                progressText.textContent = 'å‡†å¤‡ä¸‹è½½...';
                const fileName = `${options.title}_${Date.now()}.pptx`;
                
                await pptx.writeFile({ fileName });
                
                showStatus('PPTXæ–‡ä»¶ç”ŸæˆæˆåŠŸï¼', 'success');
                
            } catch (error) {
                console.error('ç”Ÿæˆå¤±è´¥:', error);
                showStatus('PPTXç”Ÿæˆå¤±è´¥: ' + error.message, 'error');
            } finally {
                generateBtn.disabled = false;
                progressInfo.classList.add('hidden');
            }
        }

        function showStatus(message, type = 'info') {
            const statusContainer = document.getElementById('statusContainer');
            const statusMessage = document.getElementById('statusMessage');
            
            const colors = {
                success: 'text-green-800 bg-green-100 border border-green-200',
                error: 'text-red-800 bg-red-100 border border-red-200',
                warning: 'text-yellow-800 bg-yellow-100 border border-yellow-200',
                info: 'text-blue-800 bg-blue-100 border border-blue-200'
            };
            
            statusMessage.className = colors[type] + ' rounded p-3';
            statusMessage.textContent = message;
            statusContainer.classList.remove('hidden');
            
            setTimeout(() => {
                statusContainer.classList.add('hidden');
            }, 5000);
        }

        // äº‹ä»¶ç›‘å¬
        document.getElementById('urlInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                addUrl();
            }
        });

        // åˆå§‹åŒ–
        window.addEventListener('load', function() {
            showStatus('HTMLå¸ƒå±€è¿˜åŸå·¥å…·å·²å°±ç»ª', 'info');
        });
    </script>
</body>
</html>